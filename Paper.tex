% This is samplepaper.tex, a sample chapter demonstrating the
% LLNCS macro package for Springer Computer Science proceedings;
% Version 2.20 of 2017/10/04
%
\documentclass[runningheads]{llncs}
%

% Used for displaying a sample figure. If possible, figure files should
% be included in EPS format.
%
% If you use the hyperref package, please uncomment the following line
% to display URLs in blue roman font according to Springer's eBook style:
% \renewcommand\UrlFont{\color{blue}\rmfamily}

\makeatletter
%\newcommand\notsotiny{\@setfontsize\notsotiny\@vipt\@viipt}
\newcommand\notsotiny{\@setfontsize\notsotiny{5}{6}}
\makeatother

\let\oldnl\nl% Store \nl in \oldnl
\newcommand{\nonl}{\renewcommand{\nl}{\let\nl\oldnl}}% Remove line number for one line

\usepackage[hyphens,spaces,obeyspaces]{url}

%\theoremstyle{definition}
%\newtheorem{exmp}{Example}[section]

\newcommand{\cmss}[1]{\textrm{{\fontfamily{cmss}\selectfont  #1}}}


\usepackage{optidef}
\usepackage[ruled,linesnumbered,noend]{algorithm2e}
\SetKwRepeat{Do}{do}{while}
\usepackage{moreverb}
\usepackage{cite}
\usepackage{graphicx}
\usepackage{graphics}
\usepackage{hyperref}
\usepackage{amsmath}
\usepackage{amsfonts, amssymb}
%\usepackage[fleqn]{amsmath} %left align
%\usepackage{amsthm}
%\usepackage{amssymb}

% for having square brackets in constraints
\usepackage{mathtools}

\newtagform{brackets}{[}{]}
\usetagform{brackets}
%

\usepackage{wrapfig} %wrapping text around image
\usepackage{xcolor} % Used for changing text color. 
\usepackage{float} % for forcing float placement
\usepackage[font=small,labelfont=bf,justification=centering]{caption} % smaller captions


%\usepackage{geometry} % to change margins
%\newgeometry{vmargin={3cm}, hmargin={30mm,30mm}}

%\usepackage[nodisplayskipstretch]{setspace}
%\setstretch{0.0}

%\usepackage[fleqn]{amsmath} %left align

%todo note
\usepackage{ulem}
\usepackage[colorinlistoftodos,prependcaption,textsize=tiny]{todonotes}
\newcommand{\jpp}[1]{{\color{teal}#1}}
\newcommand{\jppC}[1]{\todo[backgroundcolor=teal!25,bordercolor=teal]{#1}}
\normalem % removing underscore in loops and ifs
% \newcommand{\qmax}{{\textsf{q$^\textsf{max}$}}}

\begin{document}
%
\title{Production-maintenance scheduling in complex machinery}
%\title{Long-term production-maintenance scheduling on parallel machines with interacting components: A Power Transformer Case Study}
%
%\titlerunning{Abbreviated paper title}
% If the paper title is too long for the running head, you can set
% an abbreviated paper title here
%
%\author{João Dionísio\inst{1,2} \and João Pedro Pedroso\inst{1,3}}
%
%\authorrunning{Dionísio et al.}
% First names are abbreviated in the running head.
% If there are more than two authors, 'et al.' is used.
%
%\institute{1 - Faculdade de Ciências, Universidade do Porto, rua do Campo Alegre s/n, 4169–007 Porto, Portugal\\ 2 - INESC TEC 3 - CMUP}
%
%

\author{João Dionísio\inst{1,2} \and Ambros M. Gleixner\inst{3,4} \and João Pedro Pedroso\inst{1,2} \and Ksenia Bestuzheva\inst{3}}
%
\authorrunning{Dionísio \and Gleixner \and Pedroso \and Bestuzheva} % abbreviated author list (for running head)
%
%%%% list of authors for the TOC (use if author list has to be modified)
%\tocauthor{Ivar Ekeland, Roger Temam, Jeffrey Dean, David Grove,
%Craig Chambers, Kim B. Bruce, and Elisa Bertino}
%
\institute{Faculdade de Ciências, Universidade do Porto, rua do Campo Alegre s/n, $4169–007$ Porto, Portugal\\
%\email{joao.goncalves.dionisio@gmail.com}\\
\and CMUP, Centro de Matemática da Universidade do Porto
\and Zuse Institute Berlin, Takustr. $7$, $14195$ Berlin, Germany
\and Hochschule für Technik und Wirtschaft Berlin, Germany
}

\maketitle              % typeset the header of the contribution


\begin{abstract}
Long-term maintenance of machines with costly components has been studied throughout the years.
However, research on combining long-term maintenance decisions with short-term production scheduling to satisfy a predetermined demand is less prevalent, especially that which study complex machinery with multiple interacting components.
Our work contributes to this subject by studying an abstract mixed-integer nonlinear programming model, where an increase in production leads to faster degradation of components and thus creates the need for more maintenance.
We will study a Dantzig-Wolfe decomposition to solve this difficult problem, with heuristics to speed up the pricing problem.

\keywords{Production-maintenance scheduling \and Dantzig-Wolfe decomposition \and MINLP \and Resource allocation}
\end{abstract}
%
%
%
\todo[inline]{KB: to make git diffs more meaningful, it helps to write each sentence on its own line. You don't have to change everything now, but you can change this in the parts that you edit anyway. JD@KB:Done.}
\todo[inline]{KB: your use of commas is often excessive; it might come from a difference between punctuation rules in your language and English. I am removing some unneeded commas as I go, but this is something you might want to watch out for generally.}
\label{sec:intro}
\section{Introduction}

In this article, we present a MINLP with the objective of minimizing the maintenance cost of machines composed of multiple components, that must satisfy a predetermined continuous demand of a product.
We also present a Dantzig-Wolfe reformulation. 
Additionally, we develop heuristics to aid in the solving of these difficult models.

\subsubsection{Production-maintenance scheduling} ?????? EXPAND ON THE BACKGROUND ????? This problem belongs to the class of production-maintenance scheduling problems with parallel machines - see Geurtsen et al.~\cite{Production_maintenance_and_resource_scheduling_A_review} for a comprehensive literature review. 
Many variants of this problem exist and have been studied for decades, albeit less than other more classical problems. 
The majority of the literature looks at linear variants of this problem (see~\cite{Scheduling_jobs_with_time_resource_tradeoff_via_nonlinear_programming} for a resource-production exception), mostly because physical considerations tend to be ignored in more abstract models.
 Other authors avoid the nonlinearities by modeling machine failure with a random distribution~\cite{A_decomposition_method_by_interaction_prediction_for_the_optimization_of_maintenance_scheduling, Multi-component_Maintenance_Optimization:_A_Stochastic_Programming_Approach}, sometimes using Markov Chains to model a discrete set of conditions~\cite{Integrated_maintenance_planning_and_production_scheduling_with_Markovian_deteriorating_machine_conditions, markovian_model_liang_2018, Combined_Maintenance_Scheduling_and_Production_Optimization}.
  In these stochastic models, a few authors perform Bender's decomposition~\cite{Integrated_production_and_maintenance_scheduling_for_a_single_degrading_machine_with_deterioration-based_failures, Selected_topics_on_integrated_production-scheduling_and_maintenance-planning_problems}.

In his thesis, Pries focuses on decomposition approaches for joint production-maintenance scheduling problems~\cite{Selected_topics_on_integrated_production-scheduling_and_maintenance-planning_problems}, using both Bender's and Dantzig-Wolfe decomposition.
As opposed to our work, this one considers the machines as single structures, and that they are all identical.
 Furthermore, the nonlinearities we use to model the degradation, are instead replaced by random failures.

Jahromi et al. heuristically decouple the maintenance and the production decisions, to make the model more tractable~\cite{A_Two-Stage_Framework_for_Power_Transformer_Asset_Maintenance_Management—Part_I:_Models_and_Formulations}.
 Not performing these decisions at the same time allows the decision horizon for maintenance to be longer, but loses reliability as a result of the assumptions on production. 

Our work differs from the ones we could find, since we are not assuming that our parallel machines are inseparable units, but rather consider them structures composed of interacting components, which can be independently maintained.
 Furthermore, even working with abstract machines, we admit the possibility of nonlinearities in the degradation of the components, which brings the models closer to reality, and increases their difficulty, as they are mixed-integer nonlinear programs.


 \subsubsection{Maintenance in practice}
  
    Industrial maintenance tends to rely on two heuristics for maintenance scheduling: Time Based Maintenance (TbM), where maintenance is planned considering the time since the last maintenance action, and Condition Based Maintenance (CbM), where the asset is regularly tested and when some predefined threshold is reached, maintenance is scheduled (\hspace{1sp}\cite{cigre445} elaborates on this in the context of power transformers). 
    
    Research on methods for employing just-in-time maintenance is plentiful, with many of these methods resorting to machine learning, with the use of real-world data~\cite{Artificial_Intelligence_Application_for_Just_in_Time_Maintenance}.
     The idea is to perform maintenance at the precise point in time when any delay in the maintenance action would result in the failure of a component.
      As will be shown in Example~\ref{ex:non_optimal_JIT_maintenance} from Section~\ref{sec:heuristics}, this can lead to suboptimal solutions. \\

  \subsubsection{Applications} This model can be used for minimizing maintenance costs of power transformer fleets, where the ``product'' is electricity, or in water treatment stations, where the ``product'' is clean water.
   More abstractly, it can also be understood as production-maintenance scheduling in factories working in parallel with different interacting machines.
    In this last example, the factories take on the roll of the (pottentially different) machines, and the machines of the (pottentially interacting) components.\\

  This article is organized as follows: Section~\ref{sec:intro} frames the problem and provides a light background on production-maintenance problems and on maintenance practices, besides presenting the related work.
   In Section~\ref{sec:model}, the compact formulation is presented.
    Section~\ref{sec:DW} shows the Dantzig-Wolfe reformulation of this compact model, with implementation details appearing in Section~\ref{sec:implementation}.
    Due to the difficulty of this model we need some heuristics and consider some simplifications in Section~\ref{sec:heuristics}. 
    Section~\ref{sec:tests} presents the experimental setup, along with the results and corresponding discussion. 
    We conclude the paper in Section~\ref{sec:conclusion}. \\

    This work was funded by the Portuguese Foundation for Science and Technology - FCT under ????, and by Zuse Institute Berlin - ZIB.

\section{Model}
\label{sec:model}

\todo[inline]{JD: I made the tables bigger and added the decomposition parametrs/variables. What do you think?}

In the tables below are the parameters and variables of the compact formulation (the top blocks) and of the extended formulation (the bottom blocks).

\begin{table}[!htb]
    %\caption{Global caption}
      \centering
      %\hspace{-2cm}
          \resizebox{1\textwidth}{!}{
\begin{tabular}{ |p{1.5cm}||p{8cm}|p{3cm}|  }
     \hline
     Parameter & Parameter Meaning & Parameter Range\\
     \hline
    $\cmss{C}^k$   &  Cost of maintaining component $k$   & $\mathbb{R}^{+}$\\
    $\cmss{D}^k$  & Duration of component $k$'s maintenance & $\mathbb{N}$\\
    $\cmss{E}_t$   & Demand at period $t$ & $\mathbb{R}^{+}$\\
    $\mathcal{I}$  & Set of maintenance implications & $\mathcal{K}^n \times \mathcal{K}^n$\\
    $\mathcal{K}$   &  Components to be maintained & \\
    \cmss{M} & Big constant to dominate constraint & $\mathbb{R}^{+}$\\
    $\mathcal{N}$ & Set of machines & $\mathbb{N}$\\
    $\cmss{Q}^k$   &  Maximum permissible production & $\mathbb{R}^{+}$\\
    $\cmss{R}^k$   &  Maximum condition of component $k$  & $\mathbb{R}^{+}$\\
    $\mathcal{T}$   &  Set of periods   & $\mathbb{N}$\\
    \hline
    $\cmss{y}_{z,i,t}$ & Production of solution $i$ of subproblem $z$ at period $t$ & $\mathbb{R}^+$ \\
    $\mathcal{Z}$  & Set of subproblems & $\mathbb{N}$ \\
    \hline
    \end{tabular}
    }
      \caption{Description of the parameters used in the models}
    \label{tab:abstract_parameter_description}
\end{table}

\vspace*{-3em}

\begin{table}[!htb]
      \centering
          \resizebox{1\textwidth}{!}{

\begin{tabular}{ |p{1.25cm}||p{8cm}|p{2.5cm}|  }
     \hline
     Variable & Variable Meaning & Variable Type\\
     \hline
    $c$         & Objective value of solution & Discrete \\
    $r^k_{n,t}$   &  Condition of component $k$ of machine $n$ at period $t$  & Continuous\\
    $x^k_{n,t}$   &  Maintenance of component $k$ of machine $n$ at period $t$   & Binary\\
    $y_{n,t}$   &  Production of machine $n$ at period $t$ & Continuous\\
    \hline
    $\lambda_{z,i}$ & How many solutions $i$ are picked from subproblem $z$ & Integer \\
    $\pi_0$       & Dual variable associated to the convexity constraint & Continuous \\
    $\pi_t$         & Dual variable associated to time period $t$ & Continuous \\
    \hline
    \end{tabular}
}
        \caption{Description of the variables used in the models}
        \label{tab:abstract_variable_description}    
\end{table}

Below we present a general formulation of the production-maintenance scheduling problem. 
The variables are represented by lowercase letters ($x,y,r$), parameters by uppercase letters with a different font (\cmss{C}, \cmss{Q}, \cmss{M}, etc.), and sets by uppercase letters with a third font ($\mathcal{N}, \mathcal{K}, \mathcal{I}$). 
Variables and parameters will have subscripts and superscripts. 
For example, $r_{n,t}^k$ is the variable $r$ for component $k$ of machine $n$ at the time period $t$, and this nomenclature is standardized across the model.




\begin{mini!}|l|[3]
  {x,y}{c := \sum_{n \in \mathcal{N}}\sum_{t \in \mathcal{T}}\sum_{k \in \mathcal{K}^n} C^k \cdot x^k_{n,t}}
  {\label{con:cost_minimization_objective}}{}
  \addConstraint{\sum_{n \in \mathcal{N}} y_{n,t} \geq \cmss{E}_t \quad &\forall t \in \mathcal{T} \, \forall n \in \mathcal{N}}{\label{con:satisfy_demand}}
  \addConstraint{r_{n,t}^k \leq f_{n,k}(r_{n,t-1}^k, y_{n,t}; r_{n,t-1}^1, \dots, r_{n,t-1}^{|\mathcal{K}_n|}) + \cmss{M}\cdot x_{n,t}^k &\forall t,n,k}{\label{con:component_degradation}}
  \addConstraint{y_t \leq g_{n,k}(r_{n,t}^k) & \forall t \, \forall n \in \mathcal{N} \, \forall k \in \mathcal{K}}{\label{con:production_limit}}
  \addConstraint{y_{n,t} \leq (1-x^k_{n,t})\cdot \cmss{Q}^k \, & \forall t \, \forall n \in \mathcal{N} \, \forall k \in \mathcal{K}}{\label{con:maintenance_downtime}}
  \addConstraint{x^k_{n,i} \geq x^k_{n,t} - x^k_{n,t-1}\, & \forall n, k, t \leq i \leq t + \cmss{D}^k}{\label{con:maintenance_duration}}
  \addConstraint{x_{n,t}^k \leq x_{n,t}^{k^\prime} \, &\forall t \in \mathcal{T} \, \forall (k, k^\prime) \in \mathcal{I}}{\label{con:maintenance_implications}}
  \addConstraint{x^k_{n,t} \in \{0,1\} \, &\forall t \, \forall n \in \mathcal{N} \, \forall k \in \mathcal{K}}{}
  \addConstraint{y_{n,t} \geq 0 \, &\forall t \, \forall n \in \mathcal{N}}{}
  \addConstraint{0 \leq r^k_{n,t} \leq \cmss{R}^k_n \, & \forall t \, \forall n \in \mathcal{N} \, \forall k \in \mathcal{K}}{}
  \label{model:abstract_formulation}
\end{mini!}
\todo[inline]{JD@KB: Ambros prefers spelling out the sets ($\forall t \in \mathcal{T}$ instead of $\forall t$), but constraint ~\ref{con:component_degradation} is too big. What do you think?}

%Where $f$ and $g$ are convex functions.

The objective of the model is to minimize the maintenance cost (added over all components of all machines in all time periods) while guaranteeing that the machines satisfy the demand in Constraints~\eqref{con:satisfy_demand}. 
Constraints~\eqref{con:component_degradation} model the evolution of the condition of the components. 
A big-M term represents the maintenance action which, in conjunction with the binary variable $x_{n,t}^k$ will simulate the replacement of the component. 
Function $f$ will model the (possibly nonlinear) degradation of the component, which depends on its previous condition, the current production, and possibly the condition of the other components of the same machine. 
Constraints~\eqref{con:production_limit} enforce a (possibly nonlinear) upper bound on the production of a machine, based on the condition of its components.
 A machine with damaged components will not be able to produce as much as a new one. 
 Constraints~\eqref{con:maintenance_downtime} stipulate that the machines stop production while one of their components is being maintained, and Constraints~\eqref{con:maintenance_duration} impose a predetermined duration for replacing the components. 
 Finally, Constraints~\eqref{con:maintenance_implications} represent the interactions between components regarding maintenance, where the replacement of some components forces the maintenance of others. 

Since a maintenance action cannot be started if it does not have enough time to be finished, the following is a valid cut: $x_{n,t}^k \leq x_{n,|\mathcal{T}|-\cmss{D}^k}^k, \forall k, t \geq |\mathcal{T}| - \cmss{D}^k$.

\section{Dantzig-Wolfe Reformulation}
\label{sec:DW}
    The formulation above exhibits a block diagonal structure with a set of complicating constraints. 
    These are Constraints~\eqref{con:satisfy_demand}, requiring that the demand must be satisfied, while the blocks are composed of the constraints describing the functioning of the independent machines. 
    Dantzig-Wolfe decomposition is a method for solving problems with these attributes~\cite{Decomposition_Principle_for_Linear_Programs}. 
    The nonlinearities in the formulation will appear in the pricing problem, thus not directly interfering with the algorithm. 
    Example of other works with nonlinear pricing problems can be found in~\cite{Exact_Methods_for_Recursive_Circle_Packing, Security_Constrained_Economic_Dispatch_Using_Nonlinear_Dantzig-Wolfe_Decomposition, Branch-and-price_for_a_class_of_nonconvex_mixed-integer_nonlinear_programs}. 
    
    In the master problem below, we aggregate subproblems if they correspond to identical machines, as they share the same set of possible solutions. 
    With this aggregation, we expect that the usefulness of the reformulation will increase with the number of identical machines, given its symmetry-breaking characteristics. 
    Thus, the value of $\lambda_{z,i}$ will tell us how many machines in the subgroup $z$ of identical machines will use solution $i$. 
    The notation $\cmss{y}_{z,i,t}$ refers to the production in solution $i$ (from the subgroup $z$) at time $t$, and $\cmss{y}$ uses a different font to emphasize that in the master model it is a parameter. 

\begin{mini!}|l|[3]
{\lambda}{\sum_{z \in \mathcal{Z}}\sum_{i \in \mathcal{X}_z} c^\intercal \lambda_{z,i}}
{}{}
\addConstraint{\sum_{z \in \mathcal{Z}}\sum_{i \in \mathcal{X}_z} \lambda_{z,i} \cdot \cmss{y}_{z,i,t} \geq \cmss{E}_{t}, \quad & \forall t \in \mathcal{T} &\quad (\pi)}{\label{con:lambda_production_demand}}
\addConstraint{\sum_{i \in \mathcal{X}_z} \lambda_{z,i} \leq |\mathcal{Z}_z|, & \forall z \in \mathcal{Z} &\quad (\pi_0)}{\label{con:lambda_satisfaction}}
\addConstraint{0 \leq \lambda_{z,i} \leq |\mathcal{Z}_z|, & \forall z \in \mathcal{Z}}
\end{mini!}

Constraints~\eqref{con:lambda_production_demand} stipulate that the chosen solutions must satisfy the production demand. 
Computationally speaking, it makes more sense to use an inequality rather than an equation, as it tends to allow for a faster stabilization of the corresponding dual values. 
Constraints~\eqref{con:lambda_satisfaction} enforce that each subgroup of identical machines can have at most \textit{size of the subgroup} solutions.

This reformulation is solved with column generation, which will provide new production-maintenance patterns for each of the different sets of machines, looking for the ones with the lowest reduced cost. 
The dual variables from constraints~\eqref{con:lambda_production_demand} will incentivize solutions with a higher production, while the maintenance cost will prevent solutions with too many maintenance actions. 
The generation of new patterns is obtained by the pricing problem below.

\begin{mini!}|l|[3]
{x,y}{C^\intercal x - \pi^\intercal y - \pi_0}
{}{}
\addConstraint{\text{Constraints~\eqref{con:component_degradation}-~\eqref{con:maintenance_implications} being satisfied}}{\label{con:machine_operation}}
\addConstraint{y_t \leq \cmss{E}_t\, \forall t \in \mathcal{T}}{\label{con:demand_upper_bound}}
\end{mini!}

Since the production is a variable in this subproblem, $y$ uses the variable font. 

As the production demand is a clear upper bound on the production of any specific machine, Constraint~\eqref{con:demand_upper_bound} is a valid cut.

 The pricing problem can also be interpreted in the context of machine production. 
 The objective function is equivalent to the maximization of the profit of a machine (where the selling price of the product at time $t$ is given by the corresponding dual value). 
 The added valid inequality enforces a cap on production, after which the product cannot be sold, simulating markets where there is limited demand.
 A special case of this problem to power transformers was introduced by Dionísio and Pedroso in~\cite{An_Optimization_Model_for_Power_Transformer_Maintenance}.

As the pricing problem remains a MINLP, it is prohibitively expensive to solve it to optimality in every iteration.

 
\section{Extended Formulation Implementation}
\label{sec:implementation}

\todo[inline]{KB: you should be consistent about the capitalisation of the section titles (i.e. same level headings should have similar capitalisation). JD@KB:Done.}
\todo[inline]{KB: I would add some introductory text here. JD@KB: Done.}

Implementing Branch-and-Price requires a lot of effort.
Fortunately SCIP~\cite{scip9.0}, the solver used in our work, is equipped with a Branch-and-Price framework.
Nevertheless, there remains some problem-specific details which need to be implemented, described in this Section. 

\subsubsection{Initial columns generation}

We use Farkas' Pricing~\cite[p.~43]{Generic_Branch-Cut-and-Price} for initializing the RMP and for fixing infeasibilities during the Branch-and-Price process.
This technique uses Farkas' Lemma~\cite{Theorie_der_einfachen_Ungleichungen} by finding a master variable that breaks the lemma's statement and adding it to the RMP.

\subsubsection{Choice of subproblem}

As the subproblems can be very difficult when solved exactly, we will use the results of the heuristic described in Section~\ref{sec:heuristics} to decide the order in which they should be solved. 
Subproblems with a more promising heuristic result will be solved first.
After getting a column with a negative reduced cost, we advance to the next iteration in order to get more up-to-date dual values.
As the master problem is not difficult, in contrast with the pricing problem, using the best possible dual values is preferable.

\subsubsection{Branching}
  Branching on fractional master variables is inefficient, and branching on pricing variables is not possible due to the aggregation of identical subproblems - two identical machines might pick different columns in the optimal solution. 

  After solving an iteration of the RMP, we sum the columns to find a maintenance decision $x$ with a fractional value. 
  Adding the master variables that perform this maintenance action, the branching decision is to enforce that these variables must not exceed $\left \lfloor{k}\right \rfloor$ on the left branch, or that they must at least sum to $\left \lceil{k}\right \rceil$ on the right branch, where $k$ is the (necessarily fractional) sum of these master variables.

  Mathematically, the left branch adds the constraint $\sum_{\lambda \mid x_\lambda = 1} \lambda \leq \left \lfloor{k}\right \rfloor$, where $x_\lambda$ represents the value of a specific maintenance variable $x$ in the pattern associated to master variable $\lambda$.\todo{KB: make sure you define $x_\lambda$ somewhere. JD@KB: Done.}

\subsubsection{Dual bound} ?????? WORK IN PROGRESS ?????
The following is a dual bound for the master problem: ??? WHAT IS THE NAME? NEED REFERENCE ???
$$c^\ast_{\text{RMP}} + \sum_{z \in \mathcal{Z}}|\mathcal{Z}_z|\cdot min(0,w_{\text{PP}_n}) \leq c^\ast_{\text{MP}}$$,

where $c^\ast_{\text{RMP}}$ is the optimal objective of the restricted master problem, $c^\ast_{\text{MP}}$ is the optimal objective of the master problem, and $w$ is a valid dual bound for pricing problem $n$. 

\subsubsection{Parallelism}

?????? I WILL MOST LIKELY NOT BE IMPLEMENTING THIS

In decomposition approaches, solving the different subproblems in parallel can yield large speedups (in the order of $T/t$, where T is the time to solve all subproblems, and t is the time to solve the most difficult subproblem). 
While it is also possible to use parallelism to increase the speed of the compact formulation (see~\cite{Assessing_the_Effectiveness_of_(Parallel)_Branch-and-bound_Algorithms} for a review), this would take considerably more effort, both from a technical and a theoretical perspective. 
For this reason, it is our understanding that applying parallelism only to the decomposition approach is not unfair.


\section{Heuristic \& Simplifications}
\label{sec:heuristics}

Realistic instances can quickly become intractable due to the size of the problem, having many integer variables and potentially many nonlinear constraints.

\todo[inline]{KB: put this right after the first sentence of the section, since this is background. The paper's contribution would better go next. JD@KB: Done.} An iterative refinement heuristic that would be applicable to this problem can be found in a previous work of ours~\cite{An_Optimization_Model_for_Power_Transformer_Maintenance}, whose idea is limiting the number of maintenance possibilities and expanding them with every iteration.
As this heuristic did not yield a large improvement, we omit it from this paper. 


\todo[inline]{KB: I find this paragraph to be too vague to be helpful to the reader. You could clarify/expand a bit.}
For that reason, we developed a heuristic that tries to deal with this. 
It is applied to the column generation process, and remains applicable if it is used to initialize the RMP (in other words, when solving the Farkas iterations).

\label{subsubsec:PF}
\subsubsection{The production-fixing heuristic} This heuristic tries to take advantage of the impact of the production variable on the model.
Given a fixed production vector, the idea is to perform maintenance at the last possible moment, where if any maintenance action were to be delayed by one time period, the solution would be infeasible.
This maintenance strategy is referred to as just-in-time maintenance.
For a fixed production vector, Constraints~\eqref{con:production_limit} will fix the condition of the components, sans the maintenance. 
Heuristically, the fixed production vector is chosen given the Farkas' duals or the actual duals of the current iteration. 
Assuming a normal distribution with mean and standard deviation provided by these duals, the production will benefit more the more unlikely high its dual is. %Heuristically, the decision of which values the variables should be fixed to is being done with pattern-search (also known as the Hooke-Jeeves method)~\cite{Direct_Search_Solution_of_Numerical_and_Statistical_Problems}, where each variable is independently increased and decreased, and improving moves are saved. The algorithm iterates over all the variables until either a time limit or a local optimum is reached. 


\todo[inline]{KB: this assumption is important, so I would move it closer to the beginning of the section. 
And maybe mention whether the heuristic would still produce any meaningful results for the non-concave case. JD@KB: Done} 
This heuristic assumes the concavity of function $f$ for a fixed $y$, and the concavity of function $g$.
However, we were unable to create a realistic example where this would not be the case, in the context of production-maintenance scheduling.
It seems sensible to assume that if a component's condition affects another's degradation, then the worse the condition of the former, the higher the impact on the latter.
In the same way, it also seems reasonable to assume that a more degraded component will not be able to withstand more production than if it were less degraded.
In the event of a nonconcave relationship, the heuristic will incorrectly mark more production vectors as unattainable, and will also provide worse solution the less concave the degradation.
In this case the heuristic still works, but its benefit will be limited.


However, even if function $f$ is concave for a fixed $y$, and we select the best possible production vector, this heuristic is not optimal.
This is due to the interaction between components when it comes to their degradation, but also to the maintenance implication constraints (\eqref{con:maintenance_implications}).
See the following example:


\begin{example}
    Consider machines with two components, \cmss{A} and \cmss{B}, and suppose that the maintenance of the \cmss{B} implies the maintenance of component \cmss{A}.
Assume also that we have the best possible production for this heuristic. 
It may happen that component \cmss{A} is maintained in year $x$, and component \cmss{B} (and consequently, \cmss{A}) in year $y > x$. 
However, it is possible that maintaining \cmss{B} in year $x$ also leads to a feasible solution, which would save us one maintenance of component \cmss{A}. 
For example, if the total number of periods is $y+1$, it is not unreasonable that both components could have been maintained at $x$ and still reached the end without failing.
This anticipation of maintenance actions results in a solution that is strictly better than the one we started with. 

\begin{figure}[H]
    \centering
    \includegraphics[width=.5\textwidth]{Media/contraction_example.png}
    \caption{The anticipation of the \cmss{B}-\cmss{A} maintenance in the top solution leads to the bottom solution. 
    If feasible, the bottom solution is strictly better.}
    \label{fig:bad_greedy_solution}
\end{figure}
\todo[inline]{KB: I would expand the caption to briefly explain what in the figure stands for what. JD@KB:Done.}

    Note that if the bottom solution is feasible, then it is guaranteed to be an optimal solution (for this fixed production vector). 
    By construction, the original solution tells us that component \cmss{B} requires one maintenance action at $y$ at the latest, and component \cmss{A} also requires one at $x$ at the latest.
    
    The study of these types of operations is interesting, but out of scope for the present paper. 
    In a future iteration of this heuristic, they may be used to improve it.
\label{ex:non_optimal_JIT_maintenance}
\end{example}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Below follows the production-fixing algorithm used in this work.


\begin{algorithm}[H]%[H]
  \SetAlgoLined
  \KwData{$\pi$}
  
  production $\leftarrow$ getProduction($\pi$)\;
  $y_t \leftarrow$ production[t]\;
  $r^k_0 \leftarrow \cmss{R}^k, \forall k$\;
  $x^k_t \leftarrow 0, \forall k,t$\;
  
  \While{$t \leq |\mathcal{T}|$}{

    \For{$k \in \mathcal{K}^n$}{
      \If{$x^k_t = 1$}{
        continue\;
      }
      $r^k_t \leftarrow f_{n,k}(r_{n,t-1}^k, y_{n,t}; r_{n,t-1}^1, \dots, r_{n,t-1}^{|\mathcal{K}_n|})$\;
      \If {$y_t > g_{k}(r^k_{t})$}{
        $t \leftarrow \min(t, |\mathcal{T}| - \cmss{D}^k + 1)$\;
        \For{$t^\prime \in [t .. t + \cmss{D}^{k}]$}{
            $y_{t^\prime} \leftarrow 0$\;
            $x^{k}_{t^\prime} \leftarrow 1$\;
            $r^{k}_{t^\prime} \leftarrow \cmss{R}^{k}$\;
        }

        maintenanceDependencies($r,y,m$)\;
       
        }
        $t \leftarrow t-1$\;
        break\;
      }
      
      
    t $\leftarrow$ t+1\;
    }
  

  variables $\leftarrow [y,m,r]$\;
  result $\leftarrow \sum_{t \in \mathcal{T}}\sum_{k \in \mathcal{K}^n} x^k_t \cdot \cmss{C}^k$\; 
  
  \Return variables, result\;
  \caption{$\cmss{PF-heuristic}$}
  \label{algo:PF}
\end{algorithm}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{algorithm}[h]%[H]
  \SetAlgoLined
  \KwData{$\pi$}
  %\KwResult{how to write algorithm with \LaTeX2e }
    mean $\leftarrow$ mean($\pi$)\;
    std $\leftarrow$ std($\pi$)\;

    \For{$i \in \mathcal{T}$}{
      production[i] $\leftarrow$ probability[t] $\cdot$ \cmss{E}[t]/$|\mathcal{N}|$ \;
      production[i] $\leftarrow$ min(production[i], $\cmss{Q}^k$)$, \forall k$\;
    }

    \Return production\;
  \caption{$\cmss{getProduction}$}
  \label{algo:getProduction}
\end{algorithm}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{algorithm}[h]%[H]
  \SetAlgoLined
  \KwData{$r,y,x$}

  \Do{$\text{\upshape addedMaintenance = TRUE}$}{
    addedMaintenance $\leftarrow$ FALSE\;
    \For{$k^\prime \in \mathcal{K}^n$}{
      \If{$\exists k^{\prime} \mid (k^\prime, k) \in \mathcal{I} \land x^{k^{\prime}}_t < x^{k}_t$}{
        addedMaintenance $\leftarrow$ TRUE\;
        \For{$t^\prime \in [t .. t + \cmss{D}^{k^\prime}]$}{
      $y_{t^\prime} \leftarrow 0$\;
      $x^{k^\prime}_{t^\prime} \leftarrow 1$\;
      $r^{k^\prime}_{t^\prime} \leftarrow \cmss{R}^{k^\prime}$\;
      }
    }
    }

  }

  \Return $r,m,y$\;
  \caption{$\cmss{maintenanceDependencies}$}
  \label{algo:maintenanceDependencies}
\end{algorithm}


Starting with the description of the auxiliary procedure $\cmss{getProduction}$, we assume that the dual values follow a normal distribution with mean and standard deviation equal to the average and the standard deviation of the dual values, and calculate the cumulative probability of each. 
Dual values that are unexpectedly high will result in a higher production.

Onto the main procedure, $\cmss{PF-heuristic}$, we start by calling $\cmss{getProduction}$ to obtain the production vector, using the dual values given by the current iteration of the master problem. 
Iterating first over the components and then over the time periods (otherwise the impact that the components have on each others' condition would be evaluated incorrectly), we compute the condition of the current component for the current time period, as every variable of Constraint~\ref{con:component_degradation} is fixed, sans maintenance.
(And here is the assumption of concavity of $f$ for a fixed $y$, as otherwise setting the component's condition to a value lower than its upper bound might be better.) 
If the resulting condition is incompatible with the production (see Constraint~\ref{con:production_limit}. Also, here is the assumption of the concavity of $g$), then maintenance is scheduled. 
This means setting production to $0$, the condition to its optimal value, and the maintenance variables to $1$, for the duration of component $k$'s maintenance (lines $12-15$). 
Line $11$ ensures that a component does not start maintenance that it would not be able to finish.  

Due to Constraints~\ref{con:maintenance_implications}, we need to ensure that the maintenance implications are satisfied.
To this end, Algorithm~\ref{algo:maintenanceDependencies} iterates over all components $k$, and if it finds a component $k^\prime$ such that $(k^\prime,k) \in \mathcal{I}$ (and so $x^{k^\prime}_t \leq x^k_t$) which is not maintained, it schedules its maintenance.
Then it repeats the procedure, as the scheduling of $x^{k^\prime}_t$ might imply the maintenance of other components (if $\exists k^{\prime\prime} \mid (k^{\prime\prime}, k^\prime) \in \mathcal{I} \land x^{k^{\prime\prime}}_t = 0$).
The algorithm terminates when no more maintenance actions are added.

After scheduling these maintenance actions, we need to recompute the condition of the components that suffered production damage in this time period.
Since the production was set to $0$ only when analyzing component $k$, the components that preceded it were incorrectly marked as damaged.
Line $17$ computes the correct values.

Some details were excluded to make the heuristic more readable. 
For example, if when reaching line $12$ $x^k_{t^\prime}$ had already been set to $1$, then we know that this heuristic cannot provide a feasible solution, since a component in optimal condition without any production will still require maintenance. 
This can be either because the other components have a big impact on the degradation, which this heuristic does not consider, or because the instance itself is not feasible. 

% more assertive?
The choice of the production vector in Algorithm~\ref{algo:getProduction} can be more substantiated, and the results mentioned in the beginning of the section regarding maintenance anticipation should also provide better results, meaning that this heuristic can be improved upon. 


% \iffalse
% \subsubsection{1M}

% This heuristic takes the same initial observation of the PF heuristic, that the production has a disproportionate impact in the model, and assigns a production vector to each machine proportional to the number of machines. This heuristic can be thought of as the previous heuristic with a production vector of $1/|\mathcal{N}|$, but still with freedom on the remaining variables, even if they are heavily constrained. It works best when the machines are similar. If that is not the case, the production can be fixed to values proportional to the effectiveness of the machines, according to some heuristic decision.

% The model is optimized for a single machine with the production vector assigned to it, and its solution is then copied to the remaining ones.

% If we have only one type of machine, diving the demand by the number of machines can give us a near-optimal solution. However, this is not necessarily true, as the following example shows.

% \begin{example}
%     For simplicity, assume that we are studying machines with a single component, component $A$, and that there are $n$ identical machines to be maintained. Choosing appropriate parameters, suppose that by dividing the demand by $n$, the number of machines, and assigning that demand to one machine, component $A$ does not require maintenance if the number of considered periods is less than \cmss{T}, but requires one maintenance action when they equal \cmss{T}. Then, assigning maintenance to $A$ at time period $\cmss{T}-1$ would give us an optimal solution, one obtainable by the heuristic. Copying this solution to the remaining machines means that the fleet ends the study with very healthy components. Again, by choosing appropriate parameters, the demand of the final time period may be satisfiable by a proper subset of the fleet. This means that the complement of this subset incurred unnecessary maintenance, and thus the heuristic did not produce an optimal solution. 
% \label{ex:sub_optimal_1M}
% \end{example}
% \fi

\subsection{Simplifications}

\todo[inline]{KB: this is still what you are doing in the implementation, right? I would include this as a paragraph or two in the extended formulation implementation section, but I agree that this doesn't seem to be big enough for a separate subsection}

PROBABLY I'LL REMOVE THIS SUBSECTION

This model may quickly become very large, depending on the number of periods being considered, but even for average-sized instances, it can be quite difficult to solve. 

To cope with this, we assume that there are different time periods for production and maintenance decisions. 
For example, while production decisions are made every hour, maintenance might be planned on a biyearly basis. 
This forces minor modifications to the formulations, and some more significant ones, as the constraints that combine both $y$ and $x$ variables (like~\eqref{con:component_degradation}) need to use the proper indices.

Despite having a big impact on the tractability of the models, this simplification also falls in line with real-world applications, since maintenance decisions are naturally made on a much more granular scale than production decisions.


\section{Computational Experiments}
\label{sec:tests}

\subsection{Benchmark instances used}
\todo[inline]{KB: no need for a separate section to describe the instances. You can make one section for the computational experiments and include this as a subsection. JD@KB:Done.}


 In this section, we will detail the experimental setup that was used to validate the model, as well as the metrics used. 
 All the code and experiment results can be found in~\cite{github-repo}.?????? STILL NEED TO PUSH

 The instances were randomly generated. 
 They are divided by the number of time periods (either $10$, $20$, or $50$), by the number of machines (with some being identical), and they can have ``high'' or ``low'' complexity, meaning that the corresponding machines will have a higher or lower number of components with more or less interaction between them. 
 The complexity of the components also affects the amount of nonlinearity in the model. 
 For each of these combinations, we generate $10$ different instances.

 It is easy to create instances that favor each of the models, as having more or less identical machines favors the extended or the compact formulation respectively. 
 For this reason, we have opted for creating three sets of instances, with one of them having several identical machines (one group of $20$ machines), one other having many dissimilar machines ($4$ groups of $2$), and an intermediate set (one group of $5$ and one group of $2$). %Thus our test set has $10\cdot 3\cdot 2\cdot 3 = 180$ different tests.

\todo[inline]{KB: please double check that this is indeed what you meant: I rephrased the sentence. JD@KB: Done. Rephrased a bit as well.}
The varying combinations of time periods, complexity and machine groups yield $10\cdot 3\cdot 2\cdot 3 = 180$ different instances.
 
For every instance, we ran three formulations: the compact formulation, the extended formulation with exact pricing, and the extended formulation with heuristic pricing. 
In the result subsection represented by ``Compact'', ``DW'', and ``DW+PF'' respectively.\todo{KB: specify how these formulations are denoted in the tables. JD@KB: Done.}

Each of the results in Section~\ref{sec:results} represents the average of the $10$ randomly generated instances according to the relevant specification (all with the same complexity, time periods, number of machines). 
The Time column will show the average time to optimality for the instances where optimality is achieved, and the Gap (\%) column will show the average gap for the instances where it was not.
The gap is the relative gap: $\frac{|\text{primal bound} - \text{dual bound}|}{ \min(|\text{primal bound}|, |\text{dual bound}|)}$.

 
The experiments were run on two 6-Core Intel Core i7 with 64 GB running at 3.20GHz with a 30 minute time limit.
The models were solved with the SCIP solver, version 9.0.0~\cite{scip9.0}. 
For the implementation, we used SCIP's Python interface, PySCIPOpt~\cite{PySCIPOPT}, version 5.0. Some scripts (most importantly visualization with Matplotlib~\cite{matplotlib}) were implemented in Python version 3.11.4.


\subsection{Results and Analysis}\label{sec:results}

???
FIGURES $>$ TABLES?
HOW MANY INSTANCES?
WHAT TO VARY?

\begin{table}[!htb]
  \caption{Comparing effect of time}

  \scalebox{0.9}{
  \begin{minipage}{.5\linewidth}
    \caption{Results for $\mathcal{T} = 20$}
    \centering
      \begin{tabular}{|c|c|c|c|c|c|}
        \hline
        Model & $\mathcal{N}$ & Complexity & Time(s) & Gap (\%) \\
        \hline
        Compact & ??? & ??? & ??? & ??? \\
        DW & ??? & ??? & ??? & ??? \\
        DW + PF & ??? & ??? & ??? & ??? \\
        \hline
      \end{tabular}
  \end{minipage}
  }
  \scalebox{0.9}{
  \begin{minipage}{.5\linewidth}
    \centering
      \caption{Results for $\mathcal{T} = 50$}
      \begin{tabular}{|c|c|c|c|c|c|}
        \hline
        Model & $\mathcal{N}$ & Complexity & Time(s) & Gap (\%) \\
        \hline
        Compact & ??? & ??? & ??? & ??? \\
        DW & ??? & ??? & ??? & ??? \\
        DW + PF & ??? & ??? & ??? & ??? \\
        \hline
      \end{tabular}
  \end{minipage} 
  }
\end{table}



\begin{table}[!htb]
  \caption{Comparing effect of different machines}
  
  \scalebox{0.9}{
  \begin{minipage}{.5\linewidth}
    \caption{Results for $\mathcal{N} = ???$}
    \centering
    \begin{tabular}{|c|c|c|c|c|c|}
      \hline
        Model & $\mathcal{T}$ & Complexity & Time(s) & Gap (\%) \\
        \hline
        Compact & ??? & ??? & ??? & ??? \\
        DW & ??? & ??? & ??? & ??? \\
        DW + PF & ??? & ??? & ??? & ??? \\
        \hline
      \end{tabular}
  \end{minipage}
  }
  \scalebox{0.9}{
  \begin{minipage}{.5\linewidth}
    \centering
      \caption{Results for $\mathcal{N} = ???$}
      \begin{tabular}{|c|c|c|c|c|c|}
        \hline
        Model & $\mathcal{T}$ & Complexity & Time(s) & Gap (\%) \\
        \hline
        Compact & ??? & ??? & ??? & ??? \\
        DW & ??? & ??? & ??? & ??? \\
        DW + PF & ??? & ??? & ??? & ??? \\
        \hline
      \end{tabular}
  \end{minipage} 
  }
\end{table}


\todo[inline]{KB: don't you already have different complexities in the previous tables? JD@KB: Yeah, I still need to think how I want to present the results...}
\begin{table}[!htb]
  \caption{Comparing effect of machine complexity}

  \begin{minipage}{.5\linewidth}
    \caption{Results for low complexity}
    \centering
      \begin{tabular}{|c|c|c|c|c|c|}
        \hline
        Model & $\mathcal{N}$ & $\mathcal{T}$ & Time(s) & Gap (\%) \\
        \hline
        Compact & ??? & ??? & ??? & ??? \\
        DW & ??? & ??? & ??? & ??? \\
        DW + PF & ??? & ??? & ??? & ??? \\
        \hline
      \end{tabular}
  \end{minipage}
  \begin{minipage}{.5\linewidth}
    \centering
      \caption{Results for high complexity}
      \begin{tabular}{|c|c|c|c|c|c|}
        \hline
        Model & $\mathcal{N}$ & $\mathcal{T}$ & Time(s) & Gap (\%) \\
        \hline
        Compact & ??? & ??? & ??? & ??? \\
        DW & ??? & ??? & ??? & ??? \\
        DW + PF & ??? & ??? & ??? & ??? \\
        \hline
      \end{tabular}
  \end{minipage} 
\end{table}

As expected, the decomposition approaches appear advantageous in comparison to the compact model when increasing the number of identical machines. On the other hand, having more machines increases the number of pricing problems, and longer time-horizons increase their difficulty, so the compact formulation seems better suited for these instances.

An increase in machine complexity also increases the difficulty of the pricing problems....


\section{Conclusion and Future Work}
\label{sec:conclusion}

SLIGHTLY OUTDATED

This article presented a MINLP for a general production-maintenance scheduling problem. 
Besides the compact model, we also developed a Dantzig-Wolfe reformulation, and an additional heuristic due to the model's difficulty.

    The model is able to solve multiple medium-sized instances to optimality, but on larger instances, the difficulty grows rapidly. 
    The heuristic has trouble reaching optimality but can obtain good solutions very quickly, and in larger instances, it even gets better results that the original model. 
    These results leave us optimistic that we can decrease the granularity of small and medium-sized instances, and still obtain good solutions.% We based the data characterizing a power transformer on the information we could discover in the literature~\cite{cigre445}, due to the lack of quality real-world data available. 
   
    The heuristic proved to be a good complement to exact pricing.
    Besides the comments at the end of the heuristic's description, we are considering taking better advantage of how fast the heuristic is.
    Our idea is doing multiple iterations of the heuristic with different production vectors, while adding benders-like optimality and feasibility cuts, which should provide significantly better columns.

  A different extended formulation shows promising results, by reducing the number of costly pricing rounds. 
  The idea is to generate maintenance patterns and production patterns (patterns being a concrete assignment to the corresponding variables) in different pricing problems. 
  The formulation we arrived at requires more theory than this one, as it requires the simultaneous generation of columns and rows. 
  See~\cite{Simultaneous_column-and-row_generation} for more details on column-and-row generation.

  On the modeling side, more than one type of maintenance action can make the model more interesting. 
  It increases its difficulty, but it also makes it more realistic, as complete replacement of a component is usually not the only option. 
  The model can also become more general. 
  For example, there might be non-critical components that may be maintained while still allowing for some production of the machine.
   Another example is the production upper bound in Constraints\eqref{con:production_limit}, which might depend not only on the condition of individual components, but also on the joint condition of multiple components.

  Finally, the application of these techniques in real-world scenarios is also desirable. 
%    Bibliographies can be prepared with BibTeX using amsplain,
%    amsalpha, or (for "historical" overviews) natbib style.
%\bibliographystyle{amsplain}


\bibliographystyle{plainurl}
\bibliography{bibliography}
%    Insert the bibliography data here.


\end{document}
